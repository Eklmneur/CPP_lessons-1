0)
Сигнатура функции -- её отличительные особенности, которые позволяют понимать,
какую именно реализацию когда исользовать.
Т.е., это имя функции и список типов аргументов.
Одинаковые сигнатуры:
void func(int a, double &b, char c = '3')
int func(int a, double &b)
Одинаковые сигнатуры:
void func(int a, double &b, char c = '3')
int func(int a, double &b, char c)
Разные сигнатуры:
void func(int a, double &b)
int func(int a, double &b, char c)
Разные сигнатуры:
void func(int a, int b)
void func(int a, double b)
Разные сигнатуры:
void func1(int a, int b)
void func2(int a, int b)

1)
Полиморфизм -- возможность обрабатывать одной и той же функцией переменные разных типов.

2)
Перегрузка -- возможность использования одноимённых функций.
void func(int a) и void func(double a)
operator+ для разных типов
...

3)
Если в вызове присутствуют эти аргументы, действуют  как обычные аргументы.
Если отсутствуют, то вместо них подставляются значения по умолчанию.

4)
Шаблон функции показывает, как описать функцию независимо от типов аргументов.
Нужен, чтобы не прописывать по 50 раз одну и ту же функцию, где у аргументов только типы меняются.
Шаблон может оказаться нерабочим для некоторых типов аргументов,
если не определены функции или операторы для этих типов.

5)
Специализирует функцию только для некоторых типов аргументов.
Если в функцию подаётся список типов аргументов, указанный в специализации,
то используется специализация вместо шаблона.

template <typename T, typename R>
auto Mul(T &a, R &b){
return a * b;
}

template <>
auto Mul <Complex, double> (Complex &a, double &b){
return (Complex) {a.Re * b, a.Im * b};
}

6) 
если int &b = a;
то все изменения в а и b тождественны.
т.е., что бы не происходило, а = b. Кроме того &a = &b.

7)
Для ускорения работы за счёт памяти.
Вставляет функцию непосредственно в код,
чтобы лишний раз неи выполнялись функции вызова функции,
запоминания, где остановились, и возвращения.
открытия и чистки памяти на стеке.

8)
Для автоматического определения типа.
Причём auto просто автоопределение,
а decltype() возвращает тип выражения в скобках.
template <typename T, typename R>
auto Mul(T &a, R &b) -> decltype(a * b){
return (decltype(a * b)) a * b;
}
Функция возвращает значение типа, совпадающего с типом выражения a * b.