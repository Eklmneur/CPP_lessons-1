0)
Signatura funkcii -- eyo otlichitel'nye osobennosti, kotorye pozvolyayut ponimat',
kakuyu imenno realizaciyu kogda isol'zovat'.
T.e., eto imya funkcii i spisok tipov argumentov.
Odinakovye signatury:
void func(int a, double &b, char c = \'3\')
int func(int a, double &b)
Odinakovye signatury:
void func(int a, double &b, char c = \'3\')
int func(int a, double &b, char c)
Raznye signatury:
void func(int a, double &b)
int func(int a, double &b, char c)
Raznye signatury:
void func(int a, int b)
void func(int a, double b)
Raznye signatury:
void func1(int a, int b)
void func2(int a, int b)

1)
Polimorfizm -- vozmozhnost' obrabatyvat' odnoj i toj zhe funkciej peremennye raznyh tipov.

2)
Peregruzka -- vozmozhnost' ispol'zovaniya odnoimyonnyh funkcij.
void func(int a) i void func(double a)
operator+ dlya raznyh tipov
...

3)
Esli v vyzove prisutstvuyut eti argumenty, dejstvuyut  kak obychnye argumenty.
Esli otsutstvuyut, to vmesto nih podstavlyayutsya znacheniya po umolchaniyu.

4)
Shablon funkcii pokazyvaet, kak opisat' funkciyu nezavisimo ot tipov argumentov.
Nuzhen, chtoby ne propisyvat' po 50 raz odnu i tu zhe funkciyu, gde u argumentov tol'ko tipy menyayutsya.
Shablon mozhet okazat'sya nerabochim dlya nekotoryh tipov argumentov,
esli ne opredeleny funkcii ili operatory dlya etih tipov.

5)
Specializiruet funkciyu tol'ko dlya nekotoryh tipov argumentov.
Esli v funkciyu podayotsya spisok tipov argumentov, ukazannyj v specializacii,
to ispol'zuetsya specializaciya vmesto shablona.

template <typename T, typename R>
auto Mul(T &a, R &b){
return a * b;
}

template <>
auto Mul <Complex, double> (Complex &a, double &b){
return (Complex) {a.Re * b, a.Im * b};
}

6) 
esli int &b = a;
to vse izmeneniya v a i b tozhdestvenny.
t.e., chto by ne proiskhodilo, a = b. Krome togo &a = &b.

7)
Dlya uskoreniya raboty za schyot pamyati.
Vstavlyaet funkciyu neposredstvenno v kod,
chtoby lishnij raz nei vypolnyalis' funkcii vyzova funkcii,
zapominaniya, gde ostanovilis', i vozvrashcheniya.
otkrytiya i chistki pamyati na steke.

8)
Dlya avtomaticheskogo opredeleniya tipa.
Prichyom auto prosto avtoopredelenie,
a decltype() vozvrashchaet tip vyrazheniya v skobkah.
template <typename T, typename R>
auto Mul(T &a, R &b) -> decltype(a * b){
return (decltype(a * b)) a * b;
}
Funkciya vozvrashchaet znachenie tipa, sovpadayushchego s tipom vyrazheniya a * b.